<#
.SYNOPSIS
	Processes README templates with the extension *.template.md into corresponding README files with
	the extension *.md.

.DESCRIPTION
	Supports a few simple text transformation directives that must be present on their own lines:

		<!-- pack-include: file.md section-name -->
			Includes a named section from a different markdown file in which the section must be
			delimited between <!-- #region section-name --> and <!-- #endregion --> lines.

		<!-- pack-img: url -->
			Searches for the markdown image ![...](...) that immediately follows, and replaces its
			URL with the specified URL.

		<!-- pack-replace: search-string with: replacement-string -->
			Searches for the subsequent line that includes the search string, and substitutes
			occurences with the replacement string.
#>
[CmdletBinding()]
param (
	[Parameter(Mandatory)]
	[ValidateScript({ Test-Path $_ -PathType Leaf })]
	[ValidateScript({ $_.EndsWith('.template.md') })]
	[string] $Template,

	[Parameter()]
	[switch] $Preview
)

function main {
	$file = Get-Item $Template
	Set-Location $file.DirectoryName

	$targetName = $file.Name -replace '\.template\.md$', ''

	$targetText = @(
		'<!--'
		"`tGenerated with $(Split-Path $PSCommandPath -Leaf). Do not edit this file; edit the"
		"`ttemplate used to generate it instead."
		'-->'
		''
		Get-Content $file | ForEach-Object {
			$line = $_
			$trimmedLine = $line.Trim()

			if ($trimmedLine -match '<!-- pack-include: (?<file>[\w\./\/]+) (?<section>[\w\-]+) -->') {
				include $Matches.file $Matches.section
			} else {
				$line
			}
		}
	)

	if ($Preview) {
		$targetText | Out-Host
	} else {
		$targetText | Out-File "$targetName.md"
	}
}

function include {
	param (
		[ValidateScript({ Test-Path $_ }, ErrorMessage='Invalid include path')]
		[string] $File,

		[string] $Name
	)

	enum State {
		Before
		Within
		WithinPackImg
		WithinPackReplace
		After
	}

	[State] $state = 'Before'
	$stateArg = $null

	Get-Content $File | ForEach-Object {
		$line = $_
		$trimmedLine = $line.Trim()

		switch ($state) {
			'Before' {
				if ($trimmedLine -eq "<!-- #region $Name -->") {
					$state = 'Within'
				}
				break
			}

			'Within' {
				if ($trimmedLine -match '<!-- pack-img: (?<packImg>.+) -->') {
					$stateArg = $Matches.packImg
					$state = 'WithinPackImg'
				} elseif ($trimmedLine -match '<!-- pack-replace: (?<search>.+) with: (?<replacement>.+) -->') {
					$stateArg = @{
						Search = $Matches.search
						Replacement = $Matches.replacement
					}
					$state = 'WithinPackReplace'
				} elseif ($trimmedLine -eq '<!-- #endregion -->') {
					$state = 'After'
				} else {
					$line
				}
				break
			}

			'WithinPackImg' {
				if ($line -match '(?<leadingWhitespace>\s+)?!\[(?<alt>([^\]])+)?\]\(([^\)])+\)') {
					if ("$stateArg".Contains('{hash}')) {
						$stateArg = "$stateArg" -replace '{hash}', (git rev-parse HEAD)
					}
					"$($Matches.leadingWhitespace)![$($Matches.alt)]($stateArg)"
					$state = 'Within'
				}
				break
			}

			'WithinPackReplace' {
				if ($line.Contains($stateArg.Search)) {
					$line.Replace($stateArg.Search, $stateArg.Replacement)
					$state = 'Within'
				}
				break
			}
		}
	}
}

try {
	Push-Location .
	main
}
finally {
	Pop-Location
}
